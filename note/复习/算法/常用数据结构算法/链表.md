## 一、概念

链表是空间不连续的结构，不需要预先分配内存，因此比较节省空间。

一般考察单链表，因为是单向的只能获取后继，倒着遍历不容易，因此常出现一些需要倒序遍历的问题。通常情况**我们都需要记录当前节点的前驱**



## 二、解题思路

#### 1、双指针技巧

**pre + cur指针**--> 常用于反转链表，因为记录当前节点的前驱，当前节点的后继可以直接获得

**快慢指针** --> 常用与找中点、判断环、找出环的起点、找到两个相交链表的起点

**注意点**

- 调用next之前，判断当前节点是否为空
- 注意循环条件，避免死循环

#### 2、链表串成环

两个相交的链表求是否相交及交点：两个链表A B串在一起(A走到尾走B，B走到尾走A)，一个从A开始遍历 一个从B开始遍历，相遇时就是交点，交点为NULL则表示不想交.



链表左右旋转K次时，串成环遍通过遍历就能找到新链表的头部或者尾巴

**技巧**
- 1、如果需要返回头结点，或者头结点不确定的，可以创建一个 dummy_node 指向要返回的头结点，从 dummy_node.next 开始遍历
- 2、单链表只能进行顺序遍历。用双指针指向两个相邻的节点，就可以进行反转、删除等操作了



## 三、常见问题

#### 1、反转单链表    

- 使用 pre cur 两个指针，初始时pre指向null cur指向头结点 ，使用tmp临时记录cur的下一个节点
- cur不断后移直到为null
- 返回pre即为反转后的头结点

进一步：反转链表前N个元素

进一步: 反转链表指定区间的元素

进一步：K个一组反转链表

#### 2、找中点  	

使用slow  fast两个指针寻找中点

#### 3、判断回文 	

- 找到中点
- 中点之后的链表反转
- 同时遍历两个链表，结果相同则是回文

#### 4、合并链表

合并两个有序链表 --> 双指针+ 虚拟头结点

合并K个有序链表--> 借助优先级队列

链表的奇偶节点分别升序，改为整个链表升序 --> 双指针

将一个链表原地排序 --> 归并排序思路，找中点、分别排序、合并两个有序链表