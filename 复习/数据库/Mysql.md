#### 1、Mysql的数据存储结构是什么

页，页与页间是双向链表，页的记录间是单向链表，每页会生成一个页目录供主键查询时二分查找。 每次从磁盘读取一页的内容交换到内存中



#### 2、什么是索引，使用索引为什么可以提高检索速度，索引的缺点？

索引是一种数据结构，Innodb引擎有hash和B+树两种结构，默认B+树。hash索引底层是hash表，单条查询效率较高，但数据hash无序导致区间查询无法使用索引，也无法利用索引进行排序，不支持多列索引的最左匹配，同时重复键值较多的时候效率低下(存在hash碰撞)。

索引的缺点：B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会**破坏它的原有结构**。**要维持平衡树，就必须做额外的工作**。正因为这些额外的工作**开销**，导致索引会降低增删改的速度



B+树和B-树的区别：

B-树的非叶子节点也存储data，非叶子节点的data域个数+1=儿子节点个数，B-树是开区间，搜索时可能在中间某层就结束，结构如下

<img src="/Users/bjhl/Library/Application Support/typora-user-images/image-20210510203658045.png" alt="image-20210510203658045" style="zoom:50%;" />



B+树只在叶子节点存储data，非叶子节点的data域个数=儿子节点个数，叶子节点之间有链指针，**方便范围查询、排序**，孩子节点是闭区间，查询都是在叶子节点结束。

<img src="/Users/bjhl/Library/Application Support/typora-user-images/image-20210510203845723.png" alt="image-20210510203845723" style="zoom:50%;" />



#### 3、MyISAM引擎和InnoDB引擎的区别(功能上的区别，索引结构上的区别，锁的区别)

功能上MyISAM**不支持行锁、事务**、外键、崩溃后的恢复，支持读取查询时插入新纪录，缓存了行数因此COUNT运算很快

索引结构上虽然都使用B+树，MyISAM叶子结点存储的是数据的地址值，都是非聚簇索引，Innodb主键索引的叶子结点存储的就是一整条数据(聚簇索引)，非主键索引叶子结点存储记录主键的值，使用非主键索引时，除非全覆盖，否则需要回表(查非主键索引再查主键索引)



#### 4、建立索引需要遵循哪些原则？

最左匹配、选择区分度高的列作为索引(区分度高扫描的记录数少),索引列不要参与计算，尽量扩展索引不要新建索引，索引列不能为空



#### 5、Mysql5.6对索引做了什么优化？

**索引下推:作用于非主键索引**，对于AB两列构成的联合索引，查询select * from table where A>100 AND B LIKE ‘张%’ 时，会在二级索引上将符合AB的全过滤好再回表，没有这个优化前查到A大于100的后就会回表，然后查到所有记录后再过滤B like '张%'的。



#### 6、什么情况建了索引，但查询没有通过索引

一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。这就可能走了其他的索引没有走我们预想的索引。

eg:对于IN条件，我们建立了索引，但实际有可能不走索引。如果IN涉及的行数过多，Mysql就会走全表而不是走range.

ps: 可以通过设定 force index(index_name) 强制走某个索引



#### 7、数据库锁按使用方式分为几种，按粒度分几种？

首先锁针对的是索引，不是数据

1）从粒度分表锁、行锁，行锁需要通过索引条件检索数据才能使用。

表锁又分为表读锁、表写锁，**读读不阻塞，读写阻塞，写写阻塞**,**写锁是优先于读锁的**

行锁分为共享读锁、排他写锁。读锁多个客户可以**同时读取同一个**资源，但**不允许其他客户修改**。**写锁会阻塞其他的写锁和读锁**。



2）从使用方式分为乐观锁和悲观锁

悲观锁： select for update 加了写锁以后，其他的事务就不能对它修改了。

​	 select * from a where id > 100 for update 会加上间隙锁，只用于配合RR隔离级别解决幻读

乐观锁： 乐观锁不是数据库层面上的锁，是需要自己手动去加的锁。一般我们添加一个版本字段来实现



#### 8、事务的ACID，事务隔离级别是有什么实现的？MVCC的原理是什么？

1）ACID

1. A 原子性，基于undo log，事务回滚是撤销所有已成功执行的sql
2. C 一致性 事务提交前后数据都处于合法状态。由AID来保证一致性，AID是手段，C是目的
3. I 隔离性 锁和MVCC
4. D 持久性 redo log记录每次的操作，事务提交的时候redo log进行刷盘将数据修改反映到磁盘的对应分页上



2）MVCC原理

mvcc是行锁的变种，减少了加锁的操作

原理：每行后默认有两列，分别记录创建版本号及删除的版本号，每开始一个事务系统版本号会递增，**RC总是读取**创建版本号小于等于最新被提交的事务的版本号，**RR读取**创建版本号小于等于当前事务版本号，以及删除版本号没有或者大于当前事务版本号的。update是会对同一列产生一条新记录，旧记录的删除版本号是执行update的事务版本，新纪录的当前版本号也是update版本，mysql会定时清理删除版本号小于运行事务中最小版本号的行(purge)。

MVCC只是解决了读时完全不需要加锁。写的时候RR持有全部写锁到事务结束，RC只持有真正修改的记录的锁



2）事务隔离级别 （RR RC用于生产环境，其余两种基本不用）

Read uncommitted

- 会出现脏读，不可重复读，幻读。脏读：**一个事务读取到另外一个事务未提交的数据**

Read committed 

- 会出现不可重复读，幻读。不可重复读：**一个事务读取到另外一个事务已经提交的数据，也就是说一个事务可以看到其他事务所做的修改** 针对的是同一条记录
- 原理是MVCC语句级别的快照，每次读读取创建版本号小于等于最新被提交的事务的版本号

Repeatable read

- 会出现幻读(但在Mysql实现的Repeatable read配合gap锁不会出现幻读！)
- 虚读(幻读)：**是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致。**针对的是范围查询
- RR存在的问题 **丢失更新**：一个事务的更新**覆盖了其它事务的更新结果**

Serializable

- 事务串行执行，避免以上的情况！
- ![image-20210518105010944](/Users/bjhl/Library/Application Support/typora-user-images/image-20210518105010944.png)



#### 9、InnoDB 表读锁和表行锁的阻塞和兼容，MyISAM呢？  

myISAM设置concurrent_insert可以在加读锁的同时在表尾写入



#### 10、InnoDB 行锁基于什么实现？ 行锁分几种？ 意向锁是什么？如何手动加行读锁和行写锁

​    基于索引，分读共享(S) 写互斥(X), 意向锁是隐式内部使用的，在加行读/写锁前会尝试先加意向锁。默认手动加锁select ....in share mode加读锁，select ... for update加写锁



#### 11、如何降低死锁发生的概率

固定顺序访问表和行(固定顺序申请锁)

大事务拆小事务

为表添加合理的索引，减少需要获取锁的行数

降低隔离级别



#### 12、如何进行大表优化

查询限定范围，读写分离、缓存、垂直分表、水平分库



#### 13、分布式事务产生原因、解决方案

**产生原因**：service多节点-》一个交易服务访问多个数据库(积分、订单、余额)，resource多节点-》分库分表

基础:CAP，C一致性 A可用性 P分区容错性，由于存在网络延迟丢包，分区容错性是必须要的，一般在一致性和可用性间做权衡

BASE 基本可用、软状态、最终一致性，通过牺牲强一致性获取可用性

**解决方案：一般放弃强一致性追求最终一致**

1.本地消息表，第一步操作本地事务保障成功并插入到消息表中，第二步其他服务定时轮询扫描消息表 

1.1 事务消息

第一步操作完将消息放到MQ推送给对方监听，第二步其他服务消费MQ进行自己的事务。第一步需要保证事务和放MQ同时成功和失败，消费端需要保证消费失败消息不能丢失，并避免重复消费

2、两阶段提交2pc   Mycat使用的就是两阶段提交

需要一个协调者，一般需要应用充当，生成全局的事务id

1）协调者向所有参与者发送事务执行请求，等待反馈结果，

2）参与者收到请求后执行事务，但不提交，记录事务日志

3）参与者者反馈事务执行情况给协调者，阻塞等待后续指令

4）协调者收到所有参与者都能正常执行任务的回复后发送commit通知，所有参与者执行commit操作，返回commit结果

5）如果3）中回复的情况中有失败的，协调者向所有参与者发送回滚通知，所有参与者rollback，释放资源

缺点：协调者单点，一旦宕机整个集群不可用； 参与者受协调者调度期间处于阻塞状态不能执行其他操作，效率低；数据不一致，如果二阶段commit通知有的参与者没有收到，就会处于阻塞状态，导致数据不一致。  牺牲了一部分可用性换取一致性

3、三阶段提交3pc

can_commit --> pre_commit --> do_commit

如何二阶段之后迟迟没有收到协调者的commit或rollback请求，会在等待超时后继续commit，相比2pc降低了阻塞，但仍有数据不一致性

4、tcc事务补偿

 		需要对每个操作，注册语句对应的补偿操作。分布式事务的后部分失败时通过补偿操作回滚前面的操作。

对业务侵入大，改造难度大

5、尽最大努力通知 .   异步回调，类似的有支付宝微信的支付回调，不断回调直到成功，或者调用次数衰减至失败

建议使用本地消息表+事务通知， ebay 去哪儿网采用	



#### 14、大量数据的深分页

mysql查询使用select命令，配合limit，offset参数可以读取指定范围的记录。当数据量很大，offset过大时数据库压力会很大。

eg： select * from member where gender=1 limit 300000,1;

 过程：先走二级索引查到所有gender=1的记录的主键值

​    根据主键值在主键索引中查到响应的数据库，再根据offset查询300001此索引数据，最后将前30000条丢弃取最后一条。

优化：

1）如果可以提供一个id大于某值的条件，limit最近的1条是最好的，例如根据评论id翻页，每次穿一页评论的最后一条。 优点是准确且对数据库压力小，缺点是不支持跳页。

2）如果容忍页数较大时分页可能不完全精确，可以在深分页是隔段缓存起始评论id，例如1000页评论id是15000,2000页。。。。   跳页的时候找最近的缓存分页来做offset，减小offset的大小。