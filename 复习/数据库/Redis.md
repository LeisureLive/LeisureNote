## 一、数据结构

#### 1、String 

内部结构类似ArrayList，是一个带长度的字节数组， 预分配冗余空间的方式来减少内存的频繁分配。保存了最大容量capacity，当前长度len。重新分配capacity时需要复制原数组到新数组

```
struct SDS<T> {
  T capacity; // 数组容量
  T len; // 数组长度
  byte flags; // 特殊标识位，不理睬它
  byte[] content; // 数组内容
}
```

1）字符串较短时，长度和容量可以使用byte表示，节省内存

2）最长512M

3）两种存储方式，字符串长度44字节以内使用embbeded，超过使用raw。一般总体超64字节认为是大字符串，**redis对象头占14字节，中间空1字节，以及字符串最末尾的/0占一字节**，所以分界点字符串长44字节

4）扩容策略：1M内每次翻倍，1M以上每次扩1M



#### 2、list

相当于LinkedList，插入删除很快，索引定位慢。可以当队列使用。不同在于redis list实质是quick list，元素较少使用ziplist（连续内存块），元素较多时通过双向指针连接ziplist，不是单个元素一个节点，避免存储太多的附加指针浪费空间

```
struct ziplist<T> {
    int32 zlbytes; // 整个压缩列表占用字节数
    int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，用于快速定位到最后一个节点
    int16 zllength; // 元素个数
    T[] entries; // 元素内容列表，挨个挨个紧凑存储
    int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
}
```

1）默认单个 ziplist 长度为 8k 字节

2）为了节省空间还会对ziplist进行压缩，默认不压缩



#### 3、hash

相当于java中hashMap。数组 + 链表二维结构。不同的是redis map的key只能是字符串。

1）rehash时采用渐进式hash，同时保留新老两个字典，查询时同时查询，新增时写到新字典，搬迁完后删除旧结构。



#### 4、set

和hash结构相同，value固定为NULL。



#### 5、Zset

内存实现使用 跳跃列表 数据结构，查找元素LogN。数据使用快速链表存储，在其上建立多层索引方便定位元素位置。value和score存在一起，**排序时先考虑score再比较value**，避免score全部一样性能太差

删除时不是直接删除，而是有一个标记过程，遍历的时候会真正删除。



总结：

1、set hash list zset都是容器型数据结构，写入时不存在就创建，容器里元素没有了就删除key。

2、过期时间只能对顶层key设置，容器中的元素不能单个设置过期



#### 6、位图

实际就是使用string，使用bit来记录bool型数据，一个string最大512M可以记录2^32数据，用于用户签到场景



#### 7、HyperLogLog 

类似于set，可去重并计数，使用12K空间。用于海量数据近似去重



#### 二、应用

#### 1、布隆过滤器

判断元素是否出现过，已经出现过的100%成功判断。redis 4.0提供现成模块，之前需要在位图上封装。

原理：对于一个value，用多个hash算法计算hash值，判断位数组中中对应hash值是否为1，全为1就表示出现过。 位数组相对越长错误率越低

用途：redis请求前判断缓存是否存在，避免击穿。  垃圾邮件过滤



#### 2、分布式锁

1）setex原子操作加锁，value设置为自己的标识

2）解锁，判断value是自己才能解锁

​	解锁步骤：判断锁是否存在->锁存在再判断是否是自己加的-》是自己加的再解锁

​	方式1：lua脚本

​	方式2：三步操作封装到事务中(multi和exec)，加锁时对key添加watch(必须在multi之前watch一个key，只允许在当前终端的multi和exec中被修改，其他情况都会导致watch和事务的失败)，解锁时如果key被其他人修改了就解锁失败。

3）集群模式下主节点加锁成功后从节点还没来得及同步时主节点挂掉了，可能会出现两个连接同时取到锁。

解法：redlock，加锁解锁都需要半数以上节点执行成功才算成功，raft算法保障了即便主宕机新任leader必须有前任所有数据



#### 3、限流

1、zset滑动窗口实现简单限流

2、漏桶，4.0 redis-cell提供现成模块。

3、令牌桶。  瞬时高并发需要服务处理，可以采用无界队列线程池，固定核心线程数去获取令牌。



## 三、特性

#### 1、单线程模型

4.0之后引入多线程模型，但主处理程序还是单线程的，异步删除UNLINK等才会使用其他线程。

原因：

1、单线程更好维护，避免了多线程同时访问带来的并发问题

2、虽然单线程模型处理用户请求，但网络IO采用多路复用可同时处理多个客户端连接、命令

3、最重要的是，redis性能瓶颈不是cpu，而是网络io，如果不开启aof，所有redis操作不会发生任何io，性能已经非常高了，不需要引入多线程。



#### 2、支持持久化

aof 和rdb两种形式，可以混合使用

##### 1、rdb

全量快照。原理是COW（copy on write），fork一个子进程生成快照，父子进程共享内存。数据被分为数据段(页)，父进程修改时会将共享s的数据端复制一份修改，子进程始终拿到的是未被修改的数据，可以安心遍历生成快照。

##### 2、aof

1）存储顺序执行的命令。时间太长aof文件会过大，需要重写，原理时开辟子进程遍历内存

2）包括aof文件和aof缓冲区，通过fsync将内核文件刷到磁盘中，比较耗性能，一般1s一次，所以宕机可能丢失部分数据没来的及写到aof文件。



#### 3、事务

multi 指示事务的开始，exec 指示事务的执行，discard 指示事务的丢弃。

1）由于redis主程序单线程，保证事务中的多条命令连续顺序执行，满足隔离性

2）其中某条命令失败不会影响其他命令的执行

3）通常可以使用pipeline优化事务，避免事务中每条命令都需要进行一次网络io

4）discard可以清除队列中的指令，exec之前执行。

5）watch可以在multi之前监控某个key，事务执行exec时如果发现key被其他连接修改了会抛出异常，配合discard停止事务执行。



#### 4、主从同步

CAP中redis保证最终一致性，牺牲了一部分C

1）redis支持主从和从从同步

2）增量同步，同步的是指令流，使用一个环状的内存buffer记录需要同步的指令，满了会覆盖旧的，从节点反馈偏移量获取要同步的指令。

如果网络问题从节点需要同步的数据可能被覆盖，需要进行快照同步。新加入的从节点也要进行快照同步。

3）快照同步，在主库执行bgsave将内存中数据全存到快照中，然后将快照aof文件传输到从节点，从节点删除本身数据进行全量加载，加载完在进行增量同步

问题：

​     快照加载太慢可能又会触发快照同步无限循环

​	耗资源，可采用无盘同步，不同步aof文件进文件io，采用套接字将快照内容发送到从节点，主节点边遍历生成快照边发送给从节点

4）wait指令可强制等待同步完成，

5）redis哨兵类似于zk，可以选举主节点，并在主节点挂掉时切换从节点。



#### 四、常见问题

1）缓存穿透

- 布隆过滤器过滤掉请求不存在key的请求
- 请求结果为空时也缓存较短时间

2）缓存雪崩

- 本地ehcache缓存部分key避免全打到数据库
- 对key设置不同过期时间
- 及时恢复宕机机器，通过持久化尽快恢复数据

3）缓存与数据库双写的一致性问题

保证最终一致性，通过mq传递消息

4）批量删除大量key

scan + linux管道 + del，遍历中写入的数据可能漏删