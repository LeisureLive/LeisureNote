## 一、解题套路

1、路径：已经做出的选择

2、选择列表：当前可以做的选择

3、结束条件：已经到达决策树的底层，无法再做选择的条件

代码框架：

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
        
```



实质是暴力求解，在for循环中递归，递归前做选择，之后撤销选择，时间复杂度较高。

**注意**： 撤销选择时如果涉及多个变量，一定要全部都撤销



## 二、常见题

1、N皇后问题：每行、每列只能有一个皇后，皇后的左上、左下、右上、右下不能有其他皇后

2、子集、排列、组合问题

- 输入一个**不包含重复数字**的数组，输出这些数字的所有子集
- 输入两个数字 `n, k`，算法输出 `[1..n]` 中 k 个数字的所有组合
- 输入一个不包含重复数字的数组 `nums`，返回这些数字的全部排列

3、集合划分问题：将一个集合划分为K个元素和相等的子集

4、合法括号生成: 给定数字N，打印所有包含N对括号的合法字符串



## 三、如何判断适用回溯算法

1、题目可以抽象为决策树，即宽度一定(可用的选择条件数量确定)，高度一定(返回结果中包含的选择数量确定)。

2、没有明显的子问题推导关系，即问题不能由规模更小的问题的结果推导出来。