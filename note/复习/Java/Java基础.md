## 一、基础知识

##### 1、JVM是什么，JDK和JRE的区别，什么是字节码，为什么要用字节码，JIT/AOT后端编译器相比解释器的优缺点。

编译型语言，由编译器编译为硬件可执行的机器码，例如C++

解释型语言，需要专门的解释器对源程序解释成特定平台的机器码执行

Java编译可以称为前端编译，只是实现源码到二进制class文件的转化。JVM后续做了优化会将部分频繁使用的代码直接编译为机器码放入内存，加快执行速度，这才是半编译中指的编译(JIT/AOT后端编译)。



##### 2、重载和重写的区别，构造函数能否被重写？  

重载发生在编译时，多个方法的方法名相同，参数列表不同，如果调用函数时有多个方法匹配，会调用最匹配的那个。

重写实质是子类重定义继承自父类相同方法名和参数列表的方法，重写的子类返回值范围/异常范围小于等于父类，访问修饰符范围大于等于父类.构造器和私有属性不能被继承自然不能被重写



##### 3、new子类对象时，父类子类的初始化顺序

Java 子类对象初始化顺序
1.加载类阶段（类此前还未进行过初始化的时候才会触发）
父类显式初始化，静态代码块、静态变量赋初值
子类显式初始化，静态代码块、静态变量赋初值
2.创建对象
通过new关键字为子类对象分配内存空间
父类实例成员变量初始化
父类构造方法
子类实例成员变量初始化
子类构造方法
得到子类对象



##### 4、动态绑定，静态绑定是什么

动态绑定针对于重写的/同名的非private实例方法。

对于声明时使用接口，实现是具体的类，调用接口的方法时实际调用的是对应实现类的方法 

对于父类子类有同名的方法，会选择最匹配的

private变量和方法只能被类内访问，public的静态变量/静态方法/实例变量重名时静态绑定，只和声明的类型有关



##### 5、String字面量和new的区别， JDK1.6(含)前和之后字符串常量池的区别，String.intern()行为的变化

1.6之前常量池在方法区，与堆内存分开了。 new String("abc") 会在堆内存和常量池各产生一个对象，之后使用字面量时都返回常量池中对象的引用。

1.6之后常量池也放在了堆内存中，因此某些时候常量池中的字符串会指向堆内存。

String.intern 1.6之前常量池有则返回常量池的引用，没有则将字面量加入常量池并返回引用。

​                        1.6之后之后常量池有则返回常量池的引用，没有则在常量池创建指向堆对象字面量的引用

String s = "a" +"b"; 和String a = "a"; String b = "b"; String s = a+b; 的区别(前者字面量相加的结果编译优化为字面量，后者创建堆对象)



##### 6、StringBuffer和StringBuilder区别，为什么String不可变

StringBuffer方法都用synchronized加锁了，线程安全

StringBuilder线程不安全

String不可变是因为内部的char数组不可变，也是为了线程安全和性能



##### 7、抽象类和接口的区别，JDK1.8对接口的增强，为何要增强。ps:注意同时实现的接口中如果包含了相同的默认方法会报错，必须重写。

抽象类可以包含实例变量和实例方法，只能单继承，实现类必须实现所有抽象方法才可以不声明为抽象

接口1.8之后可以包含静态变量、静态方法、默认方法，但还是不能有实例变量和实例方法，可以多继承。引入默认方法是因为接口功能扩展时，已经实现接口的类不用必须实现新增的方法。



##### 8、==和equals的区别，hashCode和equals的联系，hashCode的应用场景

==比较地址值，equals一般会重写，只比较对象属性。 equals返回true的，hashCode必须返回true。用于hashMap查找同一个bucket上的链表时，先比较hashCode，相等再比较地址值。



##### 9、向下转型成功的条件    

A类对象a instanceof   类B  则a可以强转为B的对象，说明A的动态类型是B或B的子类



##### 10、泛型的原理，类型参数和通配符的区别，泛型的局限

1）原理：泛型是利于排错和方便阅读，实际编译后会进行类型擦除，都变成Object

2）`<T extend E>` 用于定义类型参数，它声明了一个类型参数T，可放在泛型类定义中类名后面、泛型方法返回值前面。

`<? extends E>` 用于实例化类型参数，它用于实例化泛型变量中的类型参数，只是这个具体类型是未知的，只知道它是E或E的某个子类型。有一个重要的限制，只能读，不能写。可以被类型参数替代

`<? super E>` 用于灵活写入或比较，使得对象可以写入父类型的容器，使得父类型的比较方法可以应用于子类对象。支持写。不能被类型参数替代

3）局限性  不能作用于基本类型，不能通过类型参数直接创建对象T[] arr = new T[10];，不能作用于静态变量和方法，不能创建泛型数组。



##### 11、为什么说Java总是值传递的。 

基本类型传递拷贝值，引用类型传递引用的复制，通过传递给方法引用的复制，可以改变引用指向的对象的属性值，但无法让原引用指向一个新对象。



##### 12、枚举类型的本质

枚举类型会被编译为一个泛型类，继承了Enum类(Enum类有两个实例变量name 和 ordinal),这个类的构造函数私有，枚举值编译后是static final修饰的，内部还有一个数组保存所有的枚举值，同时构造函数不能被反射创建实例，会抛出异常。



##### 13、反射的原理和使用

原理 ：一般操作数据的时候我们知道并依赖数据的类型，反射不一样，它在运行时动态获取类型信息，这些类型信息是类加载时每个类都会在方法区存在一份类信息，类的每个实例对象都有指向类信息的引用。类信息对应的类就是Class

使用：

1）获取类对象的途径

Class.forName(全类名)

Object.getClass

Date.class

2）通过类对象可以设置属性，调用类所有的方法(对于private方法需要设置setAccessible为true),

3）当然也可以调用构造函数创建一个类的实例对象，例如HashMap.class.newInstance();



##### 14、注解

1）作用：修饰一些类 接口 代码块 方法 字段，给他们添加额外的属性

2）创建注解: public @interface Override,@Target标明注解作用的目标是类/接口/方法/字段

@Retention标明注解保留到何时 有Source源码保留 Class字节码保留 Runtime保留到运行时

3）获取注解， 反射中获得的Field Method Class Constructor 都有getAnnotations和getAnnotation(Class)获取所有注解和指定



##### 15、**动态代理**

1）静态代理，创建被代理对象交给代理类，通过代理类调用被代理对象的方法。

2）Java SDK动态代理，**只能作用于实现了接口的类**，需要创建对象传递给invocationHandler。生成的代理类也只能强转为代理的某个接口

  原理：Proxy.newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler h)创建代理类，代理类实现了接口，实现方式就是将其转发给InvocationHandler执行，InvocationHandler中包含了被代理对象，通过反射执行被代理对象的方法，在方法调用的前后就可以添加不同的动作。



3）Cglib动态代理

cglib的实现机制与Java SDK不同，它是通过继承实现的，它也是动态创建了一个类，但这个类的父类是被代理的类，代理类重写了父类的所有public非final方法，改为调用Callback中的相关方法，callback中通过proxy.invokeSuper调用被代理类中的方法。

这也解释了为什么动态代理的方法调用本类的方法不会触发两次代理。



##### 16、类加载机制

JVM加载流程：加载->验证->准备->解析->初始化(new 反射等触发)

**加载**：将字节码从磁盘文件加载到内存

**验证**：验证类中字节码，例如final是否合规，静态变量是否合理

**准备**：为static字段分配内存，设置默认值

**解析**：把常量池中的**符号引用**转换成**直接引用**的过程

**初始化**：类的静态变量赋初始值。当类被主动使用时触发，例如new 、反射创建、 访问静态变量、 调用静态方法。classLoad.loadClass不会触发初始化。

初始化就是执行类构造器clinit的过程，clinit()方法由编译器自动产生，收集类中static{}代码块中的类变量赋值语句和类中静态成员变量的赋值语句。不是类的构造器，clinit不需要在子类调用而显式调用父类clinit，jvm自动实现。

注意一点：静态代码块只能访问到出现在静态代码块之前的变量,定义在它之后的变量,在前面的静态语句块可以赋值,但是不能访问



1）类加载器

负责将编译好的字节码加载到JVM中，一般系统提供 BootStrapCL->ExtensionCL->ApplicationCL

2)获取类加载器

每个Class对象可以调用getClassLoader获取加载它的加载器

3）class.forName 通过反射加载类并执行初始化代码

ClassLoader.loadClass(类名) **只是加载类，不执行初始化代码**  // 类加载过程的其他方法会执行初始化

4）自定义ClassLoader,集成ClassLoad类，重写findClass方法



双亲委派：任何类的加载都是BootStrapCL->ExtensionCL->ApplicationCL顺序加载，如果已经被加载过了会直接返回Class对象，如果未被加载会先使用父加载器加载，父没加载成功才自己加载。

原因：避免Java类库被覆盖。如果自己定义了java.lang.String，查看是否被加载时总是会查看BootStrapCL，发现已经被加载了就不会加载自己定义的。

自定义类加载器用途：对于同一个类，每个自定义类加载器都可以加载一次，类名一样，但类定义不同。热部署时，如果类定义被修改，使用类加载器重新加载一次，使用新的类对象通过反射生成新实例对象，替换旧的实例对象。



