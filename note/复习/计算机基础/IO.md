## 一、操作系统层面的IO模型

### 1、IO定义

IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。

一般形式： 磁盘/网络/外部设备 <----> 内核空间(缓冲区)  <------> 用户空间



### 2、IO模型

阻塞/非阻塞 对应外部空间到内核空间期间，应用程序需不需要等待

同步/异步，对应数据从内核空间复制到用户空间需不需要应用程序自己执行



#### 2.1 阻塞IO模型 

1）流程：

- 应用程序调用recvFrom接收数据，但内核空间还没准备好，**应用进程阻塞**
- 内核空间获取到数据报，将数据从内核复制到用户空间，**应用进程继续阻塞**
- 数据被复制到用户空间，应用程序进程结束阻塞读取数据

2）阻塞的是应用程序进程。两阶段都被阻塞



#### 2.2 非阻塞IO模型

1）流程

- 应用程序调用recvFrom接收数据，但内核空间还没准备好，**应用进程不阻塞**，但通过间隔调用recvFrom确认数据准备情况
- 内核空间获取到数据报，将数据从内核复制到用户空间，**应用进程阻塞**
- 数据被复制到用户空间，应用程序进程结束阻塞读取数据

2）数据还没到内核空间阶段不阻塞，但进程不断轮询比较号CPU



#### 2.3 信号驱动IO模型

1）流程

- 应用进程发送sigaction后立刻返回，不阻塞
- 内核空间获取到数据后产生一个sigIO信号
- 应用程序进程调用recvFrom，数据从内核空间复制到用户空间，**阻塞**

2）数据还没到内核空间阶段不阻塞



#### 2.4 IO复用模型

多个进程的IO注册到一个管道上统一和内核进行交互

1）流程

- 应用进程调用select获取数据，**阻塞**，注册文件描述符，select会监听所有注册的IO
- 任意一个IO所需数据到内核空间后，select返回通知应用程序
- 应用程序进程调用recvFrom，数据从内核空间复制到用户空间，**阻塞**

2）特性

- ​	没有注册信号到内核，所以**两阶段都是阻塞的**
- ​	select可以同时选择多个文件描述符，而recvFrom只能选择一个，不用每个进程产生IO时都单独创建线程去处理

3）select poll epoll

三个机制本质都是同步IO

select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。单个线程监听的文件描述符一般最多为1024。采用线性扫描获取就绪的文件描述符fd

poll 和select差别不大，采用链表保存fd，没有最大限制

epoll的fd也没有限制，但为fd指定一个回调函数，fd就绪时回调，将fd加入就绪列表，只遍历就绪的fd



#### 2.5 异步IO

1）流程

- 用户进程发起`aio_read`操作之后，给内核传递描述符、缓冲区指针、缓冲区大小、准备就绪信号等
- 内核空间获取到对应的数据，从内核空间复制到用户空间
- 发起就绪信号通知应用程序IO已完成

2）特性

两阶段都是非阻塞的，应用程序不需要等待





## 二、java对IO模型的封装

### 1、分类

java中对IO分为三类

BIO：同步阻塞，数据的读取写入必须阻塞在一个线程内等待其完成。以流方式处理数据

NIO：同步非阻塞，但同时支持阻塞与非阻塞模式，对应IO复用和 非阻塞IO/信号驱动。以块方式处理数据

AIO：异步非阻塞



### 2、NIO

有三个重要概念，channel、selector、buffer。

- 每个channel都对应一个buffer，channel是双向的。多个channel可以注册到一个selector上
- selecter对应一个线程。当selector获取到监听事件时，可以取得发生事件的channel
- 通过channel可以获取到绑定的buffer，通过channel.read(buffer)读取数据